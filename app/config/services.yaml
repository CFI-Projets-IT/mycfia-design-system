# This file is the entry point to configure your own services.
# Files in the packages/ subdirectory configure your dependencies.

# Put parameters here that don't need to change on each machine where the app is deployed
# https://symfony.com/doc/current/best_practices.html#use-parameters-for-application-configuration
parameters:
    # API CFI Configuration
    cfi.api.base_url: '%env(CFI_API_BASE_URL)%'
    cfi.api.clef: '%env(CFI_API_CLEF)%'
    cfi.api.timeout: '%env(int:CFI_API_TIMEOUT)%'
    cfi.token.ttl: '%env(int:CFI_TOKEN_TTL)%'
    cfi.token.refresh_threshold: '%env(int:CFI_TOKEN_REFRESH_THRESHOLD)%'

    # Mercure Hub Configuration (Sprint S1+)
    # URL du hub Mercure pour le streaming temps réel
    # Défaut vide pour MVP Sprint S1 (mode sync uniquement)
    mercure.default_hub: '%env(default::MERCURE_PUBLIC_URL)%'

    # Feature Flags - Authentification
    # Activer le mode d'authentification email/password (false en attendant endpoint CFI)
    cfi.auth.credentials_enabled: false

services:
    # default configuration for services in *this* file
    _defaults:
        autowire: true      # Automatically injects dependencies in your services.
        autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.

    # makes classes in src/ available to be used as services
    # this creates a service per class whose id is the fully-qualified class name
    App\:
        resource: '../src/'

    # add more service definitions when explicit configuration is needed
    # please note that last definitions always *replace* previous ones

    # Symfony AI - Token Usage Tracking
    # Active TokenOutputProcessor de Mistral pour capturer token_usage
    # Fonctionne UNIQUEMENT en mode non-streaming (voir Bridge/Mistral/TokenOutputProcessor.php:27-30)
    Symfony\AI\Platform\Bridge\Mistral\TokenOutputProcessor:
        tags:
            - { name: 'ai.output_processor', priority: 100 }

    # OutputProcessor personnalisé pour capturer le champ "model" (non capturé par TokenOutputProcessor)
    # Priorité 200 pour s'exécuter APRÈS TokenOutputProcessor
    App\Service\Ai\MistralMetadataProcessor:
        tags:
            - { name: 'ai.output_processor', priority: 200 }

    # Marketing AI Bundle - Task Persistence
    # Implémentation de TaskStorageInterface pour activer la persistence des tâches asynchrones
    # Permet le tracking historique, analytics LLM, debugging et audit
    Gorillias\MarketingBundle\Storage\TaskStorageInterface:
        class: App\Service\AppTaskStorage

    # ========================================================================
    # Marketing AI Bundle v3.32.0 - Event-driven Architecture
    # ========================================================================
    # Configuration des nouvelles interfaces abstraites pour l'execution async
    # et les notifications temps reel des agents IA.
    # ========================================================================

    # TaskDispatcherInterface - Dispatch async via Symfony Messenger
    # Permet de dispatcher des taches agents de maniere asynchrone avec UUID tracking
    Gorillias\MarketingBundle\Contract\TaskDispatcherInterface:
        class: Gorillias\MarketingBundle\Implementation\MessengerTaskDispatcher
        arguments:
            $messageBus: '@messenger.default_bus'

    # NotificationPublisherInterface - Notifications temps reel via Mercure
    # Permet au bundle de publier des notifications sans etre couple a l'infrastructure
    Gorillias\MarketingBundle\Contract\NotificationPublisherInterface:
        class: App\Service\MercureNotificationPublisher


    # CFI API Service Configuration
    App\Service\Cfi\CfiApiService:
        arguments:
            $cfiApiBaseUrl: '%cfi.api.base_url%'
            $cfiApiTimeout: '%cfi.api.timeout%'

    App\Service\Cfi\CfiAuthService:
        arguments:
            $clefApi: '%cfi.api.clef%'

    App\Service\Cfi\CfiSessionService:
        arguments:
            $tokenTtl: '%cfi.token.ttl%'
            $tokenRefreshThreshold: '%cfi.token.refresh_threshold%'

    App\Controller\ChatController:
        arguments:
            $mercurePublicUrl: '%mercure.default_hub%'

    # Service de génération JWT Mercure pour authentification EventSource
    App\Service\MercureJwtGenerator:
        arguments:
            $mercureJwtSecret: '%env(MERCURE_JWT_SECRET)%'

    # ToolResultCollector - Service singleton pour collecter les résultats des tools
    # IMPORTANT : shared: true pour garantir une instance unique partagée entre tous les services
    App\Service\ToolResultCollector:
        shared: true

    # ========================================================================
    # Marketing AI Bundle - Configuration ProjectEnrichmentAgent
    # ========================================================================
    # Surcharge pour augmenter maxTokens (2000 → 8000) suite à l'erreur
    # "Unsupported finish reason length" indiquant que la limite était atteinte.
    # Configuration alignée avec les paramètres utilisateur (Temperature: 0.7, Max Tokens: 8000)
    # ========================================================================
    Gorillias\MarketingBundle\Agent\ProjectEnrichmentAgent:
        arguments:
            $model: 'mistral-large-latest'
            $temperature: 0.7
            $maxTokens: 8000

    # ========================================================================
    # Marketing AI Bundle - Fix ServiceLocator pour ProjectEnrichmentAgent
    # ========================================================================
    # Le bundle v2.6.0-dev ne référence pas ProjectEnrichmentAgent dans le
    # ServiceLocator agent.locator, causant l'erreur "Agent service not found"
    # lors de l'exécution asynchrone via AgentTaskHandler.
    # Cette surcharge ajoute ProjectEnrichmentAgent au locator.
    # ========================================================================
    agent.locator:
        class: Symfony\Component\DependencyInjection\ServiceLocator
        arguments:
            -
                Gorillias\MarketingBundle\Agent\PersonaGeneratorAgent: '@Gorillias\MarketingBundle\Agent\PersonaGeneratorAgent'
                Gorillias\MarketingBundle\Agent\StrategyAnalystAgent: '@Gorillias\MarketingBundle\Agent\StrategyAnalystAgent'
                Gorillias\MarketingBundle\Agent\CompetitorAnalystAgent: '@Gorillias\MarketingBundle\Agent\CompetitorAnalystAgent'
                Gorillias\MarketingBundle\Agent\ContentCreatorAgent: '@Gorillias\MarketingBundle\Agent\ContentCreatorAgent'
                Gorillias\MarketingBundle\Agent\ProjectEnrichmentAgent: '@Gorillias\MarketingBundle\Agent\ProjectEnrichmentAgent'
        tags: ['container.service_locator']

    # ========================================================================
    # Marketing AI Bundle - Configuration Logger pour AgentTaskHandler
    # ========================================================================
    # Surcharge pour injecter le logger marketing.task au lieu du logger par défaut
    # Ce logger écrit dans var/log/marketing/tasks/task_execution.log
    # Permet le suivi des tâches asynchrones Messenger (dispatch, processing, completion/failure)
    # ========================================================================
    Gorillias\MarketingBundle\MessageHandler\AgentTaskHandler:
        arguments:
            $container: '@agent.locator'
            $eventDispatcher: '@event_dispatcher'
            $logger: '@monolog.logger.marketing.task'
        tags: ['messenger.message_handler']

    # ========================================================================
    # Mistral HTTP Client Configuration (Utilise timeout framework.yaml)
    # ========================================================================
    # Le client utilise automatiquement timeout: 300s configuré dans framework.yaml
    # Suffisant pour multi-personas (3-10 personas en ~85s chacune)
    # ========================================================================
    mistral.http_client:
        alias: 'http_client'  # Utilise le client HTTP par défaut (timeout: 300s)

    # ========================================================================
    # ChromaDB Client Configuration (chromadb-php v1.0)
    # ========================================================================
    # Client ChromaDB pour le stockage vectoriel RAG (Marketing AI Bundle v3.4.0+)
    # Utilisé par PersonaKnowledgeStore, CompetitorDataStore, BrandGuidelinesStore
    # Architecture v1.0 : utilise Factory au lieu de Generated\ChromaApiClient
    # ========================================================================

    # ChromaDB Factory pour création du Client
    Codewithkyrian\ChromaDB\Factory:
        calls:
            - withHost: ['%env(CHROMA_HOST)%']
            - withPort: ['%env(int:CHROMA_PORT)%']
            - withDatabase: ['marketing']
            - withTenant: ['default_tenant']

    # ChromaDB Client principal (créé via Factory)
    Codewithkyrian\ChromaDB\Client:
        factory: ['@Codewithkyrian\ChromaDB\Factory', 'connect']

    # ========================================================================
    # Screenshot Storage Service - Production Ready
    # ========================================================================
    # Stockage screenshots sur filesystem local avec abstraction S3-ready
    # Migration future : créer S3ScreenshotStorage implémentant l'interface
    # ========================================================================

    # Interface screenshot storage (pour DI)
    App\Service\Screenshot\ScreenshotStorageInterface:
        class: App\Service\Screenshot\FilesystemScreenshotStorage

    # Implémentation filesystem
    App\Service\Screenshot\FilesystemScreenshotStorage:
        arguments:
            $publicDir: '%kernel.project_dir%/public'

    # ========================================================================
    # Asset Presenter Services - Pattern Strategy pour affichage assets
    # ========================================================================
    # Auto-configuration des AssetPresenters (GoogleAds, Instagram, etc.)
    # Chaque presenter est tagué pour injection dans AssetPresenterLocator
    # ========================================================================

    # Auto-configuration des AssetPresenters avec tag app.asset_presenter
    App\Service\Marketing\AssetPresenter\:
        resource: '../src/Service/Marketing/AssetPresenter/'
        exclude: '../src/Service/Marketing/AssetPresenter/Interface/'
        tags: ['app.asset_presenter']

    # DefaultAssetPresenter : Fallback avec priorité basse (exécuté en dernier)
    # Supporte tous les types d'assets sans presenter spécialisé
    App\Service\Marketing\AssetPresenter\DefaultAssetPresenter:
        tags:
            - { name: 'app.asset_presenter', priority: -100 }

    # Service Locator avec injection automatique de tous les presenters taggés
    # Les presenters sont triés par priorité (haute → basse)
    # DefaultAssetPresenter (priority: -100) est toujours testé en dernier
    App\Service\Marketing\AssetPresenter\AssetPresenterLocator:
        arguments:
            $presenters: !tagged_iterator app.asset_presenter
